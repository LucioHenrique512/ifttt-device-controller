"use strict";

require("core-js/modules/es.symbol.description");

require("core-js/modules/es.array.filter");

require("core-js/modules/es.array.iterator");

require("core-js/modules/es.array.map");

require("core-js/modules/es.object.get-own-property-descriptors");

require("core-js/modules/es.promise");

require("core-js/modules/es.string.ends-with");

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

const _require = require('events'),
      EventEmitter = _require.EventEmitter;

const _require2 = require('path'),
      joinPath = _require2.join;

const debug = require('debug')('ps4:device');

const Detector = require('./detector');

const OnScreenKeyboard = require('./osk');

const Socket = require('./ps4socket');

const Waker = require('./waker');

const _require3 = require('./util'),
      delayMillis = _require3.delayMillis;

const DEFAULT_TIMEOUT = 10000;
const POST_CONNECT_SENDKEY_DELAY = 1500; // min delay between sendKey sends

const MIN_SENDKEY_DELAY = 200;
const HOME = process.env.HOME || process.env.HOMEPATH || process.env.USERPROFILE || '';
const DEFAULT_CREDS = joinPath(HOME, '.ps4-wake.credentials.json');
/**
 * Device is a high-level abstraction on top of a single
 *  PS4 device. It maintains a single, active connection
 *  to the device so repeated commands won't cause lots of
 *  annoying "connected" and "disconnected" messages to pop
 *  up on your device.
 *
 * Device is also an EventEmitter, and emits events from
 *  Waker and Socket.
 */

class Device extends EventEmitter {
  /**
   * Construct a new Device. Accepts an options map with
   *  the following keys:
   *
   * - address: (optional) IP address of a specific device.
   *            If omitted, will operate on the first device
   *            detected
   * - autoLogin: (default: true) If false, will skip logging
   *              into an account when waking the device.
   *              NOTE: if autoLogin is false, ONLY the following
   *              functions will work:
   *                  - turnOn()
   *                  - getDeviceStatus()
   *              Everything else will encounter errors!
   * - credentials: (optional) Path to a ps4-wake.credentials.json
   *                file to use. If not provided, uses one in the
   *                home directory of the current user.
   * - passCode: (optional) 4-digit string, if the account whose
   *             credentials we're using has set one
   * - timeout: How long network operations can be stalled before
   *            we give up on them and throw an error
   *
   * In addition, it respects the following keys from `detectOpts`,
   *  normally passed to Detector:
   *
   * - bindAddress: Address on which to bind the local udp detection
   *                socket, in case of multiple network interfaces.
   *                If omitted, will bind on the default interface.
   *                SEe dgram.Socket.bind() option `address`
   * - bindPort: Port on which to bind the local udp detection socket,
   *             in case you need to explicitly route. If omitted,
   *             will bind on any available port the system wishes
   *             to assign.
   */
  constructor(opts) {
    super();
    this.opts = _objectSpread({
      autoLogin: true,
      credentials: DEFAULT_CREDS,
      passCode: '',
      timeout: DEFAULT_TIMEOUT,
      debug: false
    }, opts);

    if (!this.opts.credentials || !this.opts.credentials.length) {
      this.opts.credentials = DEFAULT_CREDS;
    }

    if (!this.opts.timeout && this.opts.timeout !== 0) {
      this.opts.timeout = DEFAULT_TIMEOUT;
    } // see getDeviceStatus for the structure of this


    this.lastInfo = null;
    this._retryDelay = 500; // init clean state

    this._onClose();
  }
  /**
   * @return True if we believe we currently have an
   *  active connection to the device.
   */


  get isConnected() {
    return !!this._socket;
  }
  /**
   * Immediately close any active connection to this Device
   */


  close() {
    var _this = this;

    return _asyncToGenerator(function* () {
      const socket = _this._socket;
      _this.__waker = null;
      _this._socket = null;
      if (!socket) return Promise.resolve();
      socket.close();
      return new Promise((resolve, reject) => {
        socket.once('error', err => {
          reject(err);
        });
        socket.once('disconnected', () => {
          resolve();
        });
      });
    })();
  }
  /**
   * Fetch the raw device status message from the device.
   *  If this device was detected, resolves to an object
   *  that looks like:
   *
   *  {
   *      status: "Standby",
   *      statusCode: "620",
   *      statusLine: "620 Server Standby",
   *      address: "192.168.2.3",
   *      device-discovery-protocol-version: "00020020",
   *      host-name: "My PS4",
   *      host-type: "PS4",
   *      port: "997",
   *      system-version: "04550011",
   *  }
   */


  getDeviceStatus() {
    var _this2 = this;

    return _asyncToGenerator(function* () {
      const result = yield _this2._detect();
      return result.device;
    })();
  }
  /**
   * Get an active Socket instance connected to this device,
   *  turning the device on if necessary. This is a low-level
   *  method that probably won't be necessary for most users.
   */


  openSocket() {
    var _this3 = this;

    return _asyncToGenerator(function* () {
      return _this3._connect();
    })();
  }
  /**
   * Get an instance of OnScreenKeyboard, if it is possible to
   *  do so. If there is no text field on screen, this will
   *  reject with an error.
   */


  getKeyboard() {
    var _this4 = this;

    return _asyncToGenerator(function* () {
      if (_this4._osk) return _this4._osk;
      const socket = yield _this4.openSocket(); // ensure we're logged in properly

      yield _this4.login();
      return new Promise((resolve, reject) => {
        /* eslint-disable consistent-return */
        socket.startOsk((err, packet) => {
          if (err) return reject(err);
          const osk = new OnScreenKeyboard(_this4, packet);
          osk.once('close', () => {
            _this4._osk = null;
          });
          resolve(_this4._osk = osk);
        });
        /* eslint-enable consistent-return */
      });
    })();
  }
  /**
   * Send a sequence of remote key presses to this device,
   *  turning the device on if necessary. Resolves to this object.
   *  Key names are case insensitive, and can be one of:
   *
   *   up, down, left, right, enter, back, option, ps
   *
   * In addition, a key may instead be a tuple of [key, holdTime],
   *  where holdTime is an int indicating how long, in milliseconds,
   *  the key should be held for
   */


  sendKeys(keyNames) {
    var _this5 = this,
        _arguments = arguments;

    return _asyncToGenerator(function* () {
      // validate keys:
      if (!keyNames || !keyNames.length) {
        throw new Error('No keys provided');
      }

      if (_arguments.length !== 1 || !Array.isArray(keyNames)) {
        throw new Error('sendKeys must be called with an array');
      }

      const cleanKeys = keyNames.map(key => {
        if (Array.isArray(key)) {
          return [key[0].toUpperCase(), key[1]];
        }

        if (typeof key !== 'string') {
          throw new Error(`Invalid key: ${key}; must be a string or a tuple`);
        }

        return [key.toUpperCase(), 0];
      });
      const invalid = cleanKeys.filter(key => !(key[0] in Socket.RCKeys));

      if (invalid.length) {
        throw new Error(`Unknown key names: ${invalid.map(key => key[0])}`);
      }

      const socket = yield _this5.openSocket(); // ensure we're logged in properly

      yield _this5.login();

      const msSinceConnect = Date.now() - _this5._connectedAt;

      const delay = POST_CONNECT_SENDKEY_DELAY - msSinceConnect;

      if (delay > 0) {
        // give it some time to think---if we try to OPEN_RC
        //  too soon after connecting, the ps4 seems to disregard
        yield delayMillis(delay);
      }

      socket.remoteControl(Socket.RCKeys.OPEN_RC);
      yield delayMillis(MIN_SENDKEY_DELAY);
      /* eslint-disable no-await-in-loop */

      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = cleanKeys[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          const _step$value = _slicedToArray(_step.value, 2),
                key = _step$value[0],
                holdTime = _step$value[1];

          // near as I can tell, here's how this works:
          // - For a simple tap, you send the key with holdTime=0,
          //   followed by KEY_OFF and holdTime = 0
          // - For a long press/hold, you still send the key with
          //   holdTime=0, the follow it with the key again, but
          //   specifying holdTime as the hold duration.
          // - After sending a direction, you should send KEY_OFF
          //   to clean it up (since it can just be held forever).
          //   Doing this after a long-press of PS just breaks it,
          //   however.
          const val = Socket.RCKeys[key];
          socket.remoteControl(val, 0);

          if (holdTime) {
            yield delayMillis(holdTime);
            socket.remoteControl(val, holdTime);
          } // clean up the keypress. As mentioned above, after holding
          //  a direction, sending KEY_OFF seems to make further
          //  presses more reliable; doing that after holding PS button
          //  breaks it, however.


          if (!holdTime || val !== Socket.RCKeys.PS) {
            socket.remoteControl(Socket.RCKeys.KEY_OFF, 0);
          }

          if (!key.endsWith('_RC')) {
            _this5.emit('sent-key', key);
          }

          yield delayMillis(val === Socket.RCKeys.PS ? 1000 // higher delay after PS button press
          : MIN_SENDKEY_DELAY // too much lower and it becomes unreliable
          );
        }
        /* eslint-enable no-await-in-loop */

      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return != null) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      socket.remoteControl(Socket.RCKeys.CLOSE_RC);
      yield delayMillis(MIN_SENDKEY_DELAY);
      return _this5;
    })();
  }
  /**
   * Start running the application with the given ID on this
   *  device, turning the device on if necessary. Resolves
   *  to this object.
   */


  startTitle(titleId) {
    var _this6 = this;

    return _asyncToGenerator(function* () {
      const socket = yield _this6.openSocket(); // ensure we're logged in properly

      yield _this6.login();
      return new Promise((resolve, reject) => {
        socket.startTitle(titleId, err => {
          if (err) return reject(err);
          return resolve(_this6);
        });
      });
    })();
  }
  /**
   * Turn on this device, if it isn't already.
   *  Resolves to this object.
   */


  turnOn(timeOut) {
    var _this7 = this;

    return _asyncToGenerator(function* () {
      yield _this7._connect();
      let loginResult;

      if (_this7._socket) {
        // eslint-disable-next-line no-underscore-dangle
        loginResult = _this7._socket._loginResult;
      } // try to wait for a login result


      if (!loginResult || loginResult.result !== 0) {
        debug('not logged in yet; waiting for login; timeout?', timeOut);
        yield new Promise(resolve => {
          const handler = packet => {
            if (packet.result === 0) {
              _this7.removeListener('login_result', handler);

              resolve();
            }
          };

          _this7.on('login_result', handler);

          if (timeOut !== false) {
            // NOTE: for backwards compatibility, failing to login
            // is *not* an error
            setTimeout(() => resolve(), _this7.opts.timeout);
          }
        });
      } else {
        debug('already logged in!');
      }

      return _this7;
    })();
  }
  /**
   * Turn off this device (put it into standby)
   *  if it isn't already. Resolves to this object.
   */


  turnOff()
  /* _existingResolve */
  {
    var _this8 = this,
        _arguments2 = arguments;

    return _asyncToGenerator(function* () {
      // eslint-disable-line
      const socket = yield _this8._connectIfAwake();

      if (!socket) {
        // it's already off
        return _this8;
      } // ensure we're logged in properly


      yield _this8.login();
      const isRetry = _arguments2.length > 0;

      const doRequestStandby = (resolve, reject) => {
        socket.requestStandby(err => {
          if (err && isRetry) {
            reject(err);
          } else if (err) {
            // error; disconnecting and retrying
            socket.close();

            _this8._onClose();

            setTimeout(() => _this8.turnOff(resolve, reject), _this8._retryDelay);
          } else {
            resolve(_this8);
          }
        });
      };

      if (isRetry) {
        // we were provided a (resolve, reject) pair from the
        // retry above.
        // eslint-disable-next-line
        doRequestStandby(_arguments2[0], _arguments2[1]);
      } else {
        return new Promise(doRequestStandby);
      }
    })();
  }
  /**
   * Connect to the device and wake it, if it's not already
   *  awake, and ensure we're logged in. In general, methods
   *  that require logged-in state (such as `turnOff()`) will
   *  call this for you, so you probably don't need to worry
   *  about it yourself.
   */


  login() {
    var _this9 = this;

    return _asyncToGenerator(function* () {
      const errorFromResult = result => {
        if (!result.error) return null;
        return new Error(`Failed to login: ${result.error} (${result.result})`);
      };

      if (_this9._socket) {
        const _loginResult = _this9._socket._loginResult;

        if (_loginResult) {
          const e = errorFromResult(_loginResult);
          if (e) throw e;
          return _this9;
        }
      }

      return new Promise((resolve, reject) => {
        _this9.once('login_result', packet => {
          const e = errorFromResult(packet);
          if (e) reject(e);else resolve(_this9);
        });

        _this9._connect(
        /* autoLogin: */
        true);
      });
    })();
  }
  /**
   * If this device is awake, connect to it and
   *  resolve to the socket; otherwise, resolve
   *  to null.
   */


  _connectIfAwake() {
    var _this10 = this;

    return _asyncToGenerator(function* () {
      const isAwake = yield _this10._detectAwake();
      if (!isAwake) return null;
      return _this10._connect();
    })();
  }
  /**
   * Connect to this device, waking it if necessary;
   * @return the socket, or `undefined` if autoLogin is false
   */


  _connect(autoLogin) {
    var _this11 = this;

    return _asyncToGenerator(function* () {
      if (_this11._socket) return _this11._socket; // find the right device, if any

      const result = yield _this11._detect();

      const opts = _objectSpread({}, _this11.opts);

      if (autoLogin !== undefined) {
        opts.autoLogin = autoLogin;
      }

      return new Promise((resolve, reject) => {
        // we don't need to return anything from this callback:
        // eslint-disable-next-line
        _this11._waker().wake(opts, result.device, (err, socket) => {
          debug(`wake result: (autoLogin=${opts.autoLogin})`, err, `socket? ${!!socket}`);
          if (err) return reject(err);
          if (!opts.autoLogin) return resolve();
          if (!socket) return reject(new Error('No socket'));

          if (_this11._socket) {
            // close existing socket
            _this11._socket.close();

            _this11._onClose();
          }

          _this11._socket = socket;
          _this11._connectedAt = Date.now(); // forward socket events:

          socket.on('connected', () => {
            _this11.emit('connected', _this11);
          }).on('ready', () => {
            _this11.emit('ready', _this11);
          }).on('login_result', loginResult => {
            // NOTE: we're more likely to get this event from the waker
            _this11.emit('login_result', loginResult);
          }).on('login_retry', () => {
            _this11.emit('login_retry', _this11);
          }).on('error', e => {
            _this11.emit('error', e);
          }).on('disconnected', () => {
            _this11._onClose();

            _this11.emit('disconnected', _this11);
          });
          resolve(socket); // checking socket.client is a hack to
          //  confirm that we're already connected

          if (socket.client) {
            // in fact, if we have a socket here
            //  it should be connected...
            _this11.emit('connected', _this11);
          }
        });
      });
    })();
  }
  /**
   * Returns a Promise that resolves to `true` if
   *  this device is awake, and `false` if not;
   *  rejects if the device could not be found.
   */


  _detectAwake() {
    var _this12 = this;

    return _asyncToGenerator(function* () {
      const result = yield _this12._detect();
      return result.device.status.toUpperCase() === 'OK';
    })();
  }
  /**
   * Detect any device that matches our this.opts.
   * Resolves to a map that looks like:
   *  {
   *      device: <see getDeviceStatus()>,
   *      rinfo: info
   *  }
   * TODO: more information please
   */


  _detect() {
    var _this13 = this;

    return _asyncToGenerator(function* () {
      return new Promise((resolve, reject) => {
        // if the address opt was provided, detect that
        //  specific device. Otherwise, detect whatever
        const fn = _this13.opts.address ? Detector.find.bind(Detector, _this13.opts.address) : Detector.findAny.bind(Detector);
        fn(_this13.opts, (err, device, rinfo) => {
          if (err) return reject(err); // NOTE: we probably don't need to pass along rinfo...

          device.address = rinfo.address;
          device.port = device['host-request-port'];
          _this13.lastInfo = device;
          return resolve({
            device,
            rinfo
          });
        });
      });
    })();
  }
  /** reset state when disconnected */


  _onClose() {
    this._socket = null;
    this._osk = null;
    this._connectedAt = 0;
  }
  /** Create a new Waker instance */


  _waker() {
    if (this.__waker) return this.__waker; // eslint-disable-next-line

    return this.__waker = new Waker(this.opts.credentials, {
      autoLogin: this.opts.autoLogin,
      debug: this.opts.debug,
      errorIfAwake: false,
      keepSocket: true,
      ui: this.opts.ui
    }).on('need-credentials', d => {
      this.emit('need-credentials', d);
    }).on('device-notified', d => {
      this.emit('device-notified', d);
    }).on('logging-in', d => {
      this.emit('logging-in', d);
    }).on('login_result', packet => {
      // yuck
      debug('got login result from waker', packet, ' sock?', !!this._socket);
      this.emit('login_result', packet);
    });
  }

}

module.exports = Device;